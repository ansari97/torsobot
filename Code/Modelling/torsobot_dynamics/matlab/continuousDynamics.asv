function dydt = continuousDynamics(t,y,p)
%%% stanceDynamics defines the stance dynamics for the torsobot
% p is the parameter vector passed to the ode function

%% %% Define stance dynamics here
% equations of motion for a double pendulum
% See Maple files for details

% unpack variables
wheel_param = p{2};
[L, M, Iw, n, l, m, It] = wheel_param{:};

g = 9.81; % acceleration due to gravity

slope_angle = p{1}; % slope angle

% Dynamics
R = m*l*L*cos(y(1) - y(2));
S = l^2*m + It;
V = Iw + L^2*(m + M);

f1 = m*l*L*y(3)^2*sin(y(1) - y(2)) + m*g*l*sin(slope_angle + y(2));
f2 = -m*l*L*y(4)^2*sin(y(1) - y(2)) + (m + M)*g*L*sin(slope_angle + y(1));

N = [1, 0, 0, 0;
    0, 1, 0, 0;
    0, 0, R, S;
    0, 0, V, R];

f = [y(3), y(4), f1, f2]';

H = [0, 0, -1, 1]';

%% Torque function
t;
phi_desired = deg2rad(90);
phi = wrapTo2Pi(y(2)) % changed from wrap to pi
phi_dot = y(4);
% y(2);
e = phi_desired - phi
dedt = -phi_dot;
% e_sum = y(5)
e_sum = 0;

% manipulate e
if e > pi
    e = e - 2*pi;
elseif e < -pi
    e = e + 2*pi;
end

k_p = 0.65;
k_i = 0.05;
k_d = 0.08;

max_torque = 5.0;
control_max_integral= 4.0;



T = k_p*e + k_i*e_sum + k_d*dedt;
T = -T % for positive e, we need a negative torque; the +torque on torso acts in clcwise direction

% if T>=0
%     T = min(T, 2);
% else
%     T = max(T, -2);
% end

% T = 0;

%% Derivative
dydt = N\(H*T + f);
% dydt(5) = e;
end