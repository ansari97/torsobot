%%% main.m
% This file contains the main code for defining the dynamics of the 
% torsobot moving on a slope
% The normal vector to the slope defines the reference axis
% positive angles are defined anticlockwise from the slope normal
%
% Created by:
% Ahmed Alam Ansari
% 
% Updated:
% 9-18-2025

close all; % close all open figures
clear; % clear the workspace
clc; % clear command window

%% Change these variables
slope_angle = 0; % slope angle in degrees, positive slope is downwards

L = 450e-3;   % spoke length in m
M = 2*1.3;  % mass in kg
Iw = 0.3;  % moment of inertia about com/center of the wheel in kgm^2
n = 10; % number of spokes

l = 200e-3; % distance of torso coM to wheel center
m = 2; % torso mass in kg
It = m*l^2; % torso moment of inertia about the y axis coincident with the coM of the torso 

%% Initial conditions
init_theta = 0; % initial theta (wheel angle)
init_phi = deg2rad(180-0.01); % initial phi (torso angle from the reference axis)
init_theta_dot = 1; % initial theta rate
init_phi_dot = 0; % initial phi rate

%% Plotting options
phase_plot = true;
fig_plot = false; 
make_movie = false;

%% Do not change
robot_param = {L, M, Iw, n, l, m, It};
collision_angle = pi/n;

g = 9.81;   % gravitational acceleration in m/s^2

% This block corrects the initial conditions
% going up and collision angle incorrectly set to just before colliding
% up
if init_theta_dot < 0 && init_theta == -collision_angle
    init_theta = collision_angle;

% going down and collision angle incorrectly set to just before colliding
% down
elseif init_theta_dot > 0 && init_theta == collision_angle
    init_theta = -collision_angle;
end

% resetting angle value to be within range
if abs(init_theta) > collision_angle
    % if going up
    if init_theta_dot < 0
        init_theta = collision_angle;
    % if going down 
    else
        init_theta = -collision_angle;
    end
end

error_sum = 0; % for PID controller

init_con = [init_theta, init_phi, init_theta_dot, init_phi_dot];%, error_sum];

stop_vel = 0.02; % stop simulation if wheel angular velocity is less than this value

%% Solver setup
time_interval = [0 10]; % time interval for the ODE solution
solver_type = 'ode45';
solver_max_step = 0.05; % max time step
frame_skip = 10; % number of frames to skip for animation;
% skipping too many frames creates a seemingly disconneted animation

%% Do not change
solver_param = {init_con, stop_vel, time_interval, solver_type, solver_max_step};

if ~fig_plot && make_movie
    make_movie = false;
end

% Run solver and plot
[sol, event_sol, frame] = robotSimulation(slope_angle, robot_param, solver_param, phase_plot, fig_plot, frame_skip);

%% Energy graphs
theta = sol(2, :);
phi = sol(3, :);
theta_dot = sol(4, :);
phi_dot = sol(5, :);
T = 1/2*(M*L^2 + Iw + m*L^2)*theta_dot.^2 + 1/2*(m*l^2 + It)*phi_dot.^2 + m*l*L*theta_dot.*phi_dot.*cos((theta - phi));
V = g*(m+M)*L*cos(theta + deg2rad(slope_angle)) + m*g*l*cos(phi + deg2rad(slope_angle));

E = T + V;

figure;
subplot(3,1,1);
plot(sol(1, :), T);
hold on;
title("Kinetic Energy vs time");
xlabel("time(s)");
ylabel("Kinetic Energy");
hold off;

subplot(3,1,2);
plot(sol(1, :), V);
hold on;
title("Potential Energy vs time");
xlabel("time(s)");
ylabel("Potential Energy");
hold off;

subplot(3,1,3);
plot(sol(1, :), E);
hold on;
title("Total Energy vs time");
xlabel("time(s)");
ylabel("Total Energy");
hold off;

% make a video
if fig_plot && make_movie
    t = sol(1,:);
    len = length(t);
    time_max = max(t); % end time for the solution
    time_min = min(t); % start time of the solution (should be 0)

    t_movie = time_min:solver_max_step*10:time_max; % time for the movie frame
    % t_ind = zeros(length(t_movie))
    for i = 1:length(t_movie)
        ind = find(abs(t - t_movie(i)) < solver_max_step/10);

        if ~isempty(ind) > 0
            if length(ind)>1
                ind = round(mean(ind));
            end
            t_ind(i) = ind;
        elseif isempty(ind)
            % do nothing
        end
    end


    frame = frame(t_ind);
    movie(frame, 1, 10);
end
